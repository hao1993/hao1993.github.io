---
layout:     post
title:      C++
date:       2019-01-27
---

# 常用语法

## cin、cout

C++中常使用cin、cout进行控制台的输入、输出

```c++
#include <iostream>
using namespace std;

int main() {
    int age;
    cin >> age;
	
    cout << "age is " << age << endl;
    return 0;
}
```

- end是换行的意思

## 函数重载(Overload)

- 规则
  1. 函数名相同
  2. 参数个数不同、参数类型不同、参数顺序不同

- 注意
  1. 返回值类型与函数重载无关
  2. 调用函数时，实参的隐式类型转换可能会产生二义性

- 本质
  1. 采用了name mangling或者叫name decoration技术
     - C++编译器默认会对符号名(变量名、函数名等)进行改编、修饰，有些地方翻译为“命名倾轧”
     - 重载时会生成多个不同的函数名，不同编译器(MSVC、g++)有不同的生成规则
     - 通过IDA打开【VS_Release_禁止优化】可以看到

## extern “C”

被extern "C"修饰的代码会按照C语言的方式去编译

```c++
extern "C" void func() {
    cout << "func()" << endl;
}

extern "C" void func(int age) {
    cout << "func(int age) " << age << endl;
}

// 另一种写法
extern "C" {
    void func() {
        cout << "func()" << endl;
    }

    void func(int age) {
        cout << "func(int age) " << age << endl;
    }
}

//两种写法均编译失败，C语言不支持函数重载
```

如果函数同时有声明和实现，要让函数声明被extern "C"修饰，函数实现可以不修饰

```c++
extern "C" void func();
extern "C" void func(int age);

int main() {
    return 0;
}

void func() {
    cout << "func()" << endl;
}

void func(int age) {
    cout << "func(int age) " << age << endl;
}

// 另一种写法
extern "C" {
    void func();
    void func(int age);
}

int main() {
    return 0;
}

void func() {
    cout << "func()" << endl;
}

void func(int age) {
    cout << "func(int age) " << age << endl;
}

// 依旧均编译失败
```

由于C、C++编译规则的不同，在C、C++混合开发时，可能会经常出现以下操作

- C++在调用C语言API时，需要使用extern "C"修饰C语言的函数声明

```c++
// 如果是纯C语言的类，导入类
extern "C" {
    #include "sum.h"
}
```

有时也会在编写C语言代码中直接使用extern “C” ，这样就可以直接被C++调用

- 通过使用宏__cplusplus来区分C、C++环境 	

```c++
// sum.h
#ifndef sum_h
#define sum_h

#include <stdio.h>

#ifdef __cplusplus
extern "C" {
#endif
    int sum(int a, int b);

#ifdef __cplusplus
}
#endif

#endif /* sum_h */

// main.cpp
#include <iostream>
using namespace std;

#include "sum.h"

int main() {
    cout << sum(10, 20) << endl;
    return 0;
}

```

## 默认参数

C++允许函数设置默认参数，在调用时可以根据情况省略实参。规则如下:

- 默认参数只能按照右到左的顺序
- 如果函数同时有声明、实现，默认参数只能放在函数声明中
- 默认参数的值可以是常量、全局符号(全局变量、函数名)​	

```c++
int age = 30;

void test() {
    cout << "test()" << endl;
}

void display(int a = 20, int b = 10, int c = age, void(*func)() = test) {
    cout << "a is " << a << endl;
    cout << "b is " << b << endl;
    cout << "c is " << c << endl;
    func();
}

int main() {
    display();
    return 0;
}
```

函数重载、默认参数可能会产生冲突、二义性(建议优先选择使用默认参数)

```c++
void display(int a, int b = 20) {
    cout << "a is " << a << endl;
}


void display(int a) {
    cout << "a is " << a << endl;
}

int main() {
    display(10);  // 报错
    return 0;
}
```

## 内联函数

使用inline修饰函数的声明或者实现，可以使其变成内联函数

- 建议声明和实现都增加inline修饰	

特点：

- 编译器会将函数调用直接展开为函数体代码
- 可以减少函数调用的开销
- 会增大代码体积

注意：

- 尽量不要内联超过10行代码的函数
- 有些函数即使声明为inline，也不一定会被编译器内联，比如递归函数

函数代码量不是很多，函数的调用频率比较高，可以使用内联函数。

### 内联函数与宏

- 内联函数和宏，都可以减少函数调用的开销
- 对比宏，内联函数多了语法检测和函数特性

```c++
// 以下代码是有区别的，宏只是做了替换
#define sum(x) x + x
inline sum(int x) {return x + x};
int a = 10, sum(a++);
```

## #pragma once

- 我们经常使用#ifndef、#define、#endif来防止头文件的内容被重复包含
- `#pragma once`可以防止整个文件的内容被重复包含

**区别**：

- `#ifndef、#define、#endif`受C\C++标准的支持，不受编译器的任何限制
- 有些编译器不支持`#pragma once`(较老编译器不支持，如GCC 3.4版本之前)，兼容性不够好
- `#ifndef、#define、#endif`可以针对一个文件中的部分代码，而#pragma once只能针对整个文件

## 引用(Reference)

-  在C语言中，使用指针(Pointer)可以间接获取、修改某个变量的值
-  在C++中，使用引用(Reference)可以起到跟指针类似的功能

```c++
int age = 20;
// rage就是一个引用
int &rAge = age;

int *a[4]  // a是指针数组，存放4个指针的数组
int (*b)[4] // b是指向数组的指针，指向的那个数组可以存放4个int型的元素
```

注意点：

- 引用相当于是变量的别名(基本数据类型、枚举、结构体、类、指针、数组等，都可以有引用)
- 对引用做计算，就是对引用所指向的变量做计算
- 在定义的时候就必须初始化，一旦指向了某个变量，就不可以再改变，“从一而终”
- 可以利用引用初始化另一个引用，相当于某个变量的多个别名
- 不存在【引用的引用、指向引用的指针、引用数组】

引用存在的价值之一:比指针更安全、函数返回值可以被赋值

### 引用的本质

- 引用的本质就是指针，只是编译器削弱了它的功能，所以引用就是弱化了的指针
- 一个引用占一个指针的大小

### 数组的引用

```c++
int array[] = {1, 2, 3, 4};
int (&rArray)[4] = array;
rArray[1] = 5;

// 另一种写法
int * const &rArray2 = array;
```

## const

const是常量的意思，被其修饰的变量不可修改

- 如果修饰的是类、结构体(的指针)，其成员也不可以更改 

```c++
// 以下5个指针分别代表什么含义
int age = 10;
const int *p0 = &age;  // *p0是常量  p0不是常量
int const *p1 = &age;  // *p1是常量  p1不是常量
int * const p2 = &age;	// p2是常量，*p2不是常量
const int * const p3 = &age;  // 都是常量
int const * const p4 = &age;  // 都是常量	 
// 上面的指针问题可以用以下结论来解决：
// const修饰的是其右边的内容
```

### 常引用(Const Reference)

引用可以被const修饰，这样就无法通过引用修改数据了，可以称为常引用

- const必须写在&符号的左边，才能算是常引用

const引用的特点：

- 可以指向临时数据(常量、表达式、函数返回值等)
- 可以指向不同类型的数据
- 作为函数参数时(此规则也适用于const指针)
  - 可以接受const和非const实参(非const引用，只能接受非const实参)
  - 可以跟非const引用构成重载

**当常引用指向了不同类型的数据时，会产生临时变量，即引用指向的并不是初始化时的那个变量**

```C++
	int age = 10;
	const long &rAge = age;
	age = 30;
	cout << "age is " << age << endl;
	cout << "rAge is " << rAge << endl; 
// age is 30
// rAge is 10

    int age = 10;
    const int &rAge = age;
    age = 30;
    cout << "age is " << age << endl;
    cout << "rAge is " << rAge << endl;
// age is 30
// rAge is 30
```

## 汇编语言

### x64汇编要点总结

- mov dest, src
  - 将src的内容赋值给dest，类似于dest = src

- [ 地址值 ]
  - 中括号[ ]里面放的都是内存地址

- word是2字节，dword是4字节(double word)，qword是8字节(quad word)

- call 函数地址
  - 调用函数

- lea dest, [ 地址值 ]
  - 将地址值赋值给dest，类似于dest = 地址值

- ret
  - 函数返回

- xor op1, op2
  - 将op1和op2异或的结果赋值给op1，类似于op1 = op1 ^ op2

- add op1, op2
  - 类似于op1 = op1 + op2

- sub op1, op2
  - 类似于op1 = op1 - op2

- inc op
  - 自增，类似于op = op + 1

- dec op
  - 自减，类似于op = op – 1

- jmp 内存地址
  - 跳转到某个内存地址去执行代码
  - j开头的一般都是跳转，大多数是带条件的跳转，一般跟test、cmp等指令配合使用

**一个变量的地址值是它所有子节中的最小地址值**

## 表达式

C++的有些表达式是可以被赋值的

```c++
int a = 1;
int b = 2;
(a = b) = 3; // 赋值给了a
(a < b ? a = b) = 4; // 赋值给了b
```

# 面向对象

## 类

- C++中可以使用struct、class来定义一个类
- struct和class的区别：
  - struct的默认成员权限是public
  - class的默认成员权限是private

![avatars](https://ws4.sinaimg.cn/large/006tNc79ly1fzjtrd04bqj31j00bagqq.jpg)

- 上面代码中person对象、pPerson指针的内存都是在函数的栈空间，自动分配和回收的
- 可以尝试反汇编struct和class，看看是否有其他区别
- 实际开发中，用class表示类比较多

### C++编程规范

- 每个人都可以有自己的编程规范，没有统一的标准，没有标准答案，没有最好的编程规范
- 变量名规范参考
  - 全局变量:g_
  - 成员变量:m_
  - 静态变量:s_
  - 常量:c_
  - 使用驼峰标识

### 对象的内存布局

思考:如果类中有多个成员变量，对象的内存又是如何布局的?

```c++
struct Person {
    int m_id;
    int m_age;
    int m_height;
    void display() {
        cout << "m_id is " << m_id << endl;
        cout << "m_age is " << m_age << endl;
        cout << "m_height is " << m_height << endl;
    }
}; 
```

![avatars](https://ws2.sinaimg.cn/large/006tNc79ly1fzk1ge8apnj30p20iawjm.jpg)

### 指针访问对象成员的本质

思考:最后打印出来的每个成员变量值是多少?

```c++
// 创建对象
Person person;
person.m_id = 10;
person.m_age = 20;
person.m_height = 30;

// 创建指针
Person *pPerson = (Person *)&person.m_age;
pPerson->m_id = 40;
pPerson->m_age = 50;

// 打印
person.display();   // 10  40   50

pPerson.display(); // 40 50 -2394(未知)
```

### this

this是指向当前对象的指针

象在调用成员函数的时候，会自动传入当前对象的内存地址

```c++
struct Person {
    int m_id;
    int m_age;
    int m_height;
    void display() {
        cout << "m_id is " << this->m_id << endl;
        cout << "m_age is " << this->m_age << endl;
        cout << "m_height is " << this->m_height << endl;
    }
};
```

- 可以利用this.m_age来访问成员变量么?
  - 不可以，因为this是指针，必须用this->m_age

### 封装

成员变量私有化，提供公共的getter和setter给外界去访问成员变量

```c++
struct Person {
private:
    int m_age;
public:
    void setAge(int age) {
        // 过滤
        if (age < 0) return;
        this->m_age = age;
    }
    int getAge() {
        return this->m_age;
    }
};

Person person;
person.setAge(20);
cout << person.getAge() << endl;
```

### 内存空间的布局

**每个应用都有自己独立的内存空间，其内存空间一般都有以下几大区域**

![avatars](https://ws4.sinaimg.cn/large/006tNc79ly1fzk4d8rhy9j302g03edfo.jpg)

- 代码段(代码区)
  - 用于存放代码

- 数据段(全局区)
  - 用于存放全局变量等

- 栈空间
  - 每调用一个函数就会给它分配一段连续的栈空间，等函数调用完毕后会自动回收这段栈空间
  - 自动分配和回收

- 堆空间
  - 需要主动去申请和释放

### 堆空间

- 在程序运行过程，为了能够自由控制内存的生命周期、大小，会经常使用堆空间的内存

- 堆空间的申请\释放
  - malloc \ free
  - new \ delete
  - new [] \ delete []

注意：

- 申请堆空间成功后，会返回那一段内存空间的地址
- 申请和释放必须是1对1的关系，不然可能会存在内存泄露

现在的很多高级编程语言不需要开发人员去管理内存(比如Java)，屏蔽了很多内存细节，利弊同时存在

- 利:提高开发效率，避免内存使用不当或泄露
- 弊:不利于开发人员了解本质，永远停留在API调用和表层语法糖，对性能优化无从下手

#### 堆空间的初始化

```c++
    int *p1 = (int *)malloc(sizeof(int));  // *p1未初始化
    int *p2 = (int *)malloc(sizeof(int));
    memset(p2, 0, sizeof(int)); // 将*p2的每个字节都初始化为0

    int *p1 = new int;        // 未被初始化
    int *p2 = new int();      // 被初始化为0
    int *p3 = new int(5);     // 被初始化为5
    int *p4 = new int[3];     // 数组元素未被初始化
    int *p5 = new int[3]();   // 3个数组元素都被初始化为0
    int *p6 = new int[3]{};   // 3个数组元素都被初始化为0
    int *p7 = new int[3]{5};  // 数组的首元素被初始化为5，其他元素被初始化为0
```

#### memset

memset函数是将较大的数据结构(比如对象、数组等)内存清零的比较快的方法

```c++
    Person person;
    person.m_id = 1;
    person.m_age = 20;
    person.m_height = 50;
    memset(&person, 0, sizeof(person));

    //Person persons[] = {{1, 20, 30}, {2, 30, 50}, {3, 200, 300}};
    //memset(persons, 0, sizeof(persons));
```

### 对象的内存

对象的内存可以存在于3种地方

- 全局区(数据段):全局变量
- 栈空间:函数里面的局部变量
- 堆空间:动态申请内存(malloc、new等)

```c++
Person g_person;  // 全局区

int main () {
	Person person; // 栈空间
    
    Person *p = new Person(); // 堆空间
    p->m_age = 20;
    delete p;
    
    return 0;
}		
```

## 构造函数(Constructor)

构造函数(也叫构造器)，在对象创建的时候自动调用，一般用于完成对象的初始化工作

特点：

- 函数名与类同名，无返回值(void都不能写)，可以有参数，可以重载，可以有多个构造函数
- 一旦自定义了构造函数，必须用其中一个自定义的构造函数来初始化对象	

注意：

- 通过malloc分配的对象不会调用构造函数

**一个广为流传的、很多教程\书籍都推崇的错误结论:**

- 默认情况下，编译器会为每一个类生成空的无参的构造函数 X  错误的结论

**正确理解:在某些特定的情况下，编译器才会为类生成空的无参的构造函数**

### 构造函数的调用

![avatars](https://ws1.sinaimg.cn/large/006tNc79ly1fzl07223vvj30ry08sdja.jpg)

## 成员变量的初始化

对象初始化

```c++
Person() {
    memset(this, 0, sizeof(Person));
}
```

### 默认情况下，成员变量的初始化

```c++
struct Person {
    int m_age;
}

// 全局区（成员变量初始化为0） 
Person g_p1;

int main() {
    // 栈空间（成员变量不会被初始化）
    Person p1;
    
    // 堆空间
    Person *p2 = new Person;       // 成员变量不会被初始化
    Person *p3 = new Person();	   // 成员变量初始化为0
    Person *p4 = new Person[3];	   // 成员变量不会被初始化
    Person *p5 = new Person[3]();  // 3个Person对象的成员变量都初始化为0
    Person *p6 = new Person[3]{};  // 3个Person对象的成员变量都初始化为0
    
    return 0;
}
```

- 如果自定义了构造函数，除了全局区，其他内存空间的成员变量默认都不会被初始化，需要开发人员手动初始化

## 析构函数(Destructor)

析构函数(也叫析构器)，在对象销毁的时候自动调用，一般用于完成对象的清理工作

特点：

- 函数名以~开头，与类同名，无返回值(void都不能写)，无参，不可以重载，有且只有一个析构函数

注意：

- 过malloc分配的对象free的时候不会调用构造函数

构造函数、析构函数要声明为public，才能被外界正常使用

```c++
struct Person {
	Car *m_car;
    
    Person() {
        this->m_car = new Car();
    }
    
    // 内存回收、清理工作（回收Person对象内部申请的堆空间）
    ~Person() {
        delete this->m_car;
    }
}
```

### 声明和实现分离

![avatars](https://ws3.sinaimg.cn/large/006tNc79ly1fzl8u3tb2rj30p60c2q52.jpg)

`::`是域运算符，跟在函数名前面

### 命名空间

命名空间可以用来避免命名冲突

![avatars](https://ws3.sinaimg.cn/large/006tNc79ly1fzl9n6rqmfj30oo0awq46.jpg)

#### 命名空间的嵌套

![avatars](https://ws4.sinaimg.cn/large/006tNc79ly1fzl9zb8pvlj30r80coabv.jpg)

默认的命名空间，没有名字

#### 命名空间的合并

以下两种写法是等价的：

```c++
namespace H {
    ing g_age;
}

namespace H {
    ing g_no;
}

// 第二种写法
namespace H {
    ing g_age;
    ing g_no;
}

```

## 继承

继承，可以让子类拥有父类的所有成员(变量\函数)

```c++
struct Person {
	int m_age;
    void run() {
        cout << "Person:run()" << endl;
    }
}

struct Student: Person {
    int m_no;
    void study() {
        cout << "Student:study()" << endl;
    }
}

int main() {
    Student student;
    student.m_age = 20;
    student.m_no = 3;
    student.run();
    student.study();
    
    return 0;
}
```

- 关系描述：
  - Student是子类（subclass，派生类）
  - Person是父类（superclass，超类）

- C++中没有像Java、Objective-C的基类
  - Java:java.lang.Object
  - Objective-C：NSObject

### 对象的内存布局

![avatars](https://ws4.sinaimg.cn/large/006tNc79ly1fzlfklujjtj30q80c240t.jpg)

### 成员访问权限

成员访问权限、继承方式有3种：

- public:公共的，任何地方都可以访问(struct默认)
- protected:子类内部、当前类内部可以访问
- prvate:私有的，只有当前类内部可以访问(class默认)

子类内部访问父类成员的权限，是以下2项中权限最小的那个

- 成员本身的访问权限
- 上一级父类的继承方式	

开发中用的最多的继承方式是public，这样能保留父类原来的成员访问权限

访问权限不影响对象的内存布局

### 初始化列表

特点：

- 一种便捷的初始化成员变量的方式
- 只能用在构造函数中
- 初始化顺序只跟成员变量的声明顺序有关

```c++
struct Person {
    int m_age;
    int m_height;
    Person(int age, int height) {
        this->m_age = age;
        this->m_height = heigh;
    }
}
// 这两种写法是等价的
struct Person {
    int m_age;
    int m_height;
    Person(int age, int height): m_age(age), m_height(height) {
       
    }
}

```

### 构造函数的互相调用

![avatars](https://ws3.sinaimg.cn/large/006tNc79ly1fzlhp1mtiqj31640oegql.jpg)

