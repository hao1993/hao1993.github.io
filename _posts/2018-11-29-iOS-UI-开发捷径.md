---
layout:     post
title:      《iOS UI 开发捷径》笔记
date:       2018-11-29
---

# 第1章：Interface Builder 概要

- 简单来说，IB就是苹果公司给开发者提供的可视化UI开发工具。
- IB也是可以做封装的。大家完全可以将父类定义的`@IBOutlet`属性和`@IBAction`方法与子类进行“连线”，而且可以与多个子类进行连线，这样可以利用父类控制统一的逻辑，而子类则利用`IB`完成不同的`UI`布局，这是`IB`利于封装很明显的优势，只是在实际开发中很少被使用罢了。

# 第2章：使用 Interface Builder

- 如果一个`IB`文件用`Source Code`的方式都无法打开的话，那么可以尝试用文本编辑器打开它。

- `xib`既可以与继承自`UIView`的子类进行“关联”，也可以与继承于`UIViewController`的子类进行“关联”，与前者的“关联”需要选中`xib`中的`View`，在`Show the Indetity inspector`中将`Class`标签的值改为相应的`UIView`子类的类名，与后者的“关联”需要选中`xib`中的`File's Owner`，在`Show the Indetify inspecotr`中将`Class`标签的值改为相应的`UIViewController`子类的类名。完成了“关联”之后，就可以将`xib`文件与相应的源文件进行`@IBOutle`t和`@IBAction`“连线”了

- 在初学`IB`遇到`crash`时，首先判断`IB`文件是否正确加载到了指定的`Bundle`，其次判断“连线”是否正确，是否有一些“荒废的连线”。

- 个人认为，在`IB`学习中有很多细小而有用的地方，需要自己去发现和总结，这是`IB`学习的特点，如何灵活地将它们运用在实际开发中，是`IB`学习的难点，也是使用`IB`开发的魅力所在。

- ``````objective-c
  NSArray *viewArray = [[NSBundle mainBundle] loadNibNamed:@"ToolBar" owner:nil options:nil];
  ToolBar *normalToolBar = viewArray[0];
  ToolBar1 *editToolBar1 = viewArray[1]
  ``````

- 之所以用代码设置是因为`IB`文件加载图片时默认会从`main bundle`中找，而通常`SDK`的`IB`和图片资源是单独打包到一个`Bundle`中的，因此对于要使用`SDK`的主工程来说，是不知道如何加载该`IB`中的图片的，因为主工程的`Bundle`中并没有这些资源，从这个侧面可以看出，相对于普通的开发，`SDK`开发还是有一些不同之处的。

- 在`xib`和`sb`中都是可以放多个元素的，这里之所以用“元素”来表达这个意思，是因为在`xib`中可以放多个View，而在`sb`中可以放多个`VC`。在`xib`中每个元素的加载是通过返回的`Any`的顺序来区分的，而`sb`中每个`VC`的加载是通过`storyboadID`来区分的。
- 总的来说，`xib`的使用方法和使用场景比较复杂，而`sb`的使用方法很简单，也便于理解，而且功能强大，除非在某些情况下用`xib`特别适合，否则的话，建议开发中多用`xib`。

- 在`OC`工程中有一个`main.m`的文件，`App`启动时首先初始化所有的类（注意这一步是初始化类，而不是实例），然后调用`main.m`中的`main`函数，可以把`App`的启动过程简单划分成两个阶段：1.从类的初始化到`main`函数的执行；2.从`main`函数的执行到`application:didFinishLaunchingWithOptions`的执行。

```objective-c
int main(int argc, char * argv[]) {
    @autoreleasepool {
        return UIApplication(argc, argv, nil, NSStringFromClass([AppDelegate class]));
    }
}
```

`UIApplicationMain`函数的参数:

1. `argc`，是`int`类型，代表程序启动时的参数个数，默认是1.

2. `argh`，是`char*[]`类型，代表各个参数的值，默认为程序的名字。

3. `principalClassName`，是`NSString*`类型，该参数必须传一个`UIApplication`或其子类的类名对应的字符串，用于实例化一个`UIApplication`或其子类对象，大多数情况传`nil`，传`nil`就是用`UIApplication`类的名字对应的字符串作为参数，相当于传了`NSStringFromClass([UIApplication class])`，但实际上这是一个很有用的参数，如果要针对`UIApplication`来完成一些事情的话，那么可以自定义一个`UIApplication`的子类。例如有一些各个页面都需要处理的烦琐事情，想在某个类中集中处理，就可以考虑自定义一个`UIApplication`的子类，通过设置这个参数，在该子类中统一做这些事情，而不是将这些事情分散到各个页面对应的`VC`中处理。例如：`App`日志的统计类似于这样的一种需求：如果要记录`App`的行为日志，但又不想每个页面对应的`VC`都处理这种琐碎的事情，而是更希望这些`VC`做一些它们自己负责的交互与业务逻辑的事情。

4. `delegateClassName`，也是`NSString*`类型，指定一个继承于`UIResponder`并遵循`UIApplicationDelegate`协议的类的实例，这个类由`Xcode`的模版准备，及`Appdelegate`类。


#第3章：全面学习`xib`

- `Show the Identity inspector->Documents->Lock`可以将一个控件的属性锁定，使其无法被修改。当编辑好一个控件后，不希望由于误操作对其再次编辑的话就可以用`Document->Lock`将其锁定，尤其是可以锁定控件的位置，这个方法很实用。